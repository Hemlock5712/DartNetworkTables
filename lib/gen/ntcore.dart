// ignore_for_file: camel_case_types, non_constant_identifier_names, constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for wpilib ntcore
class ntcore {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  ntcore(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  ntcore.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.Int> _nt = _lookup<ffi.Int>('nt');

  int get nt => _nt.value;

  set nt(int value) => _nt.value = value;

  /// Get default instance.
  /// This is the instance used by non-handle-taking functions.
  ///
  /// @return Instance handle
  int NT_GetDefaultInstance() {
    return _NT_GetDefaultInstance();
  }

  late final _NT_GetDefaultInstancePtr =
      _lookup<ffi.NativeFunction<NT_Inst Function()>>('NT_GetDefaultInstance');
  late final _NT_GetDefaultInstance =
      _NT_GetDefaultInstancePtr.asFunction<int Function()>();

  /// Create an instance.
  ///
  /// @return Instance handle
  int NT_CreateInstance() {
    return _NT_CreateInstance();
  }

  late final _NT_CreateInstancePtr =
      _lookup<ffi.NativeFunction<NT_Inst Function()>>('NT_CreateInstance');
  late final _NT_CreateInstance =
      _NT_CreateInstancePtr.asFunction<int Function()>();

  /// Destroy an instance.
  /// The default instance cannot be destroyed.
  ///
  /// @param inst Instance handle
  void NT_DestroyInstance(
    int inst,
  ) {
    return _NT_DestroyInstance(
      inst,
    );
  }

  late final _NT_DestroyInstancePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Inst)>>(
          'NT_DestroyInstance');
  late final _NT_DestroyInstance =
      _NT_DestroyInstancePtr.asFunction<void Function(int)>();

  /// Get instance handle from another handle.
  ///
  /// @param handle    handle
  /// @return Instance handle
  int NT_GetInstanceFromHandle(
    int handle,
  ) {
    return _NT_GetInstanceFromHandle(
      handle,
    );
  }

  late final _NT_GetInstanceFromHandlePtr =
      _lookup<ffi.NativeFunction<NT_Inst Function(NT_Handle)>>(
          'NT_GetInstanceFromHandle');
  late final _NT_GetInstanceFromHandle =
      _NT_GetInstanceFromHandlePtr.asFunction<int Function(int)>();

  /// Get Entry Handle.
  ///
  /// @param inst      instance handle
  /// @param name      entry name (UTF-8 string)
  /// @param name_len  length of name in bytes
  /// @return entry handle
  int NT_GetEntry(
    int inst,
    ffi.Pointer<ffi.Char> name,
    int name_len,
  ) {
    return _NT_GetEntry(
      inst,
      name,
      name_len,
    );
  }

  late final _NT_GetEntryPtr = _lookup<
      ffi.NativeFunction<
          NT_Entry Function(
              NT_Inst, ffi.Pointer<ffi.Char>, ffi.Size)>>('NT_GetEntry');
  late final _NT_GetEntry = _NT_GetEntryPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// Gets the name of the specified entry.
  /// Returns an empty string if the handle is invalid.
  ///
  /// @param entry     entry handle
  /// @param name_len  length of the returned string (output parameter)
  /// @return Entry name
  ffi.Pointer<ffi.Char> NT_GetEntryName(
    int entry,
    ffi.Pointer<ffi.Size> name_len,
  ) {
    return _NT_GetEntryName(
      entry,
      name_len,
    );
  }

  late final _NT_GetEntryNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              NT_Entry, ffi.Pointer<ffi.Size>)>>('NT_GetEntryName');
  late final _NT_GetEntryName = _NT_GetEntryNamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Size>)>();

  /// Gets the type for the specified key, or unassigned if non existent.
  ///
  /// @param entry   entry handle
  /// @return Entry type
  int NT_GetEntryType(
    int entry,
  ) {
    return _NT_GetEntryType(
      entry,
    );
  }

  late final _NT_GetEntryTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(NT_Entry)>>(
          'NT_GetEntryType');
  late final _NT_GetEntryType =
      _NT_GetEntryTypePtr.asFunction<int Function(int)>();

  /// Gets the last time the entry was changed.
  /// Returns 0 if the handle is invalid.
  ///
  /// @param entry   entry handle
  /// @return Entry last change time
  int NT_GetEntryLastChange(
    int entry,
  ) {
    return _NT_GetEntryLastChange(
      entry,
    );
  }

  late final _NT_GetEntryLastChangePtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(NT_Entry)>>(
          'NT_GetEntryLastChange');
  late final _NT_GetEntryLastChange =
      _NT_GetEntryLastChangePtr.asFunction<int Function(int)>();

  /// Get Entry Value.
  ///
  /// Returns copy of current entry value.
  /// Note that one of the type options is "unassigned".
  ///
  /// @param entry     entry handle
  /// @param value     storage for returned entry value
  ///
  /// It is the caller's responsibility to free value once it's no longer
  /// needed (the utility function NT_DisposeValue() is useful for this
  /// purpose).
  void NT_GetEntryValue(
    int entry,
    ffi.Pointer<NT_Value> value,
  ) {
    return _NT_GetEntryValue(
      entry,
      value,
    );
  }

  late final _NT_GetEntryValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              NT_Entry, ffi.Pointer<NT_Value>)>>('NT_GetEntryValue');
  late final _NT_GetEntryValue = _NT_GetEntryValuePtr.asFunction<
      void Function(int, ffi.Pointer<NT_Value>)>();

  /// Set Default Entry Value.
  ///
  /// Returns copy of current entry value if it exists.
  /// Otherwise, sets passed in value, and returns set value.
  /// Note that one of the type options is "unassigned".
  ///
  /// @param entry     entry handle
  /// @param default_value     value to be set if name does not exist
  /// @return 0 on error (value not set), 1 on success
  int NT_SetDefaultEntryValue(
    int entry,
    ffi.Pointer<NT_Value> default_value,
  ) {
    return _NT_SetDefaultEntryValue(
      entry,
      default_value,
    );
  }

  late final _NT_SetDefaultEntryValuePtr = _lookup<
      ffi.NativeFunction<
          NT_Bool Function(
              NT_Entry, ffi.Pointer<NT_Value>)>>('NT_SetDefaultEntryValue');
  late final _NT_SetDefaultEntryValue = _NT_SetDefaultEntryValuePtr.asFunction<
      int Function(int, ffi.Pointer<NT_Value>)>();

  /// Set Entry Value.
  ///
  /// Sets new entry value.  If type of new value differs from the type of the
  /// currently stored entry, returns error and does not update value.
  ///
  /// @param entry     entry handle
  /// @param value     new entry value
  /// @return 0 on error (type mismatch), 1 on success
  int NT_SetEntryValue(
    int entry,
    ffi.Pointer<NT_Value> value,
  ) {
    return _NT_SetEntryValue(
      entry,
      value,
    );
  }

  late final _NT_SetEntryValuePtr = _lookup<
      ffi.NativeFunction<
          NT_Bool Function(
              NT_Entry, ffi.Pointer<NT_Value>)>>('NT_SetEntryValue');
  late final _NT_SetEntryValue = _NT_SetEntryValuePtr.asFunction<
      int Function(int, ffi.Pointer<NT_Value>)>();

  /// Set Entry Flags.
  ///
  /// @param entry     entry handle
  /// @param flags     flags value (bitmask of NT_EntryFlags)
  void NT_SetEntryFlags(
    int entry,
    int flags,
  ) {
    return _NT_SetEntryFlags(
      entry,
      flags,
    );
  }

  late final _NT_SetEntryFlagsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Entry, ffi.UnsignedInt)>>(
          'NT_SetEntryFlags');
  late final _NT_SetEntryFlags =
      _NT_SetEntryFlagsPtr.asFunction<void Function(int, int)>();

  /// Get Entry Flags.
  ///
  /// @param entry     entry handle
  /// @return Flags value (bitmask of NT_EntryFlags)
  int NT_GetEntryFlags(
    int entry,
  ) {
    return _NT_GetEntryFlags(
      entry,
    );
  }

  late final _NT_GetEntryFlagsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(NT_Entry)>>(
          'NT_GetEntryFlags');
  late final _NT_GetEntryFlags =
      _NT_GetEntryFlagsPtr.asFunction<int Function(int)>();

  /// Read Entry Queue.
  ///
  /// Returns new entry values since last call. The returned array must be freed
  /// using NT_DisposeValueArray().
  ///
  /// @param subentry     subscriber or entry handle
  /// @param count        count of items in returned array (output)
  /// @return entry value array; returns NULL and count=0 if no new values
  ffi.Pointer<NT_Value> NT_ReadQueueValue(
    int subentry,
    ffi.Pointer<ffi.Size> count,
  ) {
    return _NT_ReadQueueValue(
      subentry,
      count,
    );
  }

  late final _NT_ReadQueueValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NT_Value> Function(
              NT_Handle, ffi.Pointer<ffi.Size>)>>('NT_ReadQueueValue');
  late final _NT_ReadQueueValue = _NT_ReadQueueValuePtr.asFunction<
      ffi.Pointer<NT_Value> Function(int, ffi.Pointer<ffi.Size>)>();

  /// Get Published Topic Handles.
  ///
  /// Returns an array of topic handles.  The results are optionally
  /// filtered by string prefix and type to only return a subset of all
  /// topics.
  ///
  /// @param inst          instance handle
  /// @param prefix        name required prefix; only topics whose name
  /// starts with this string are returned
  /// @param prefix_len    length of prefix in bytes
  /// @param types         bitmask of NT_Type values; 0 is treated specially
  /// as a "don't care"
  /// @param count         output parameter; set to length of returned array
  /// @return Array of topic handles.
  ffi.Pointer<NT_Topic> NT_GetTopics(
    int inst,
    ffi.Pointer<ffi.Char> prefix,
    int prefix_len,
    int types,
    ffi.Pointer<ffi.Size> count,
  ) {
    return _NT_GetTopics(
      inst,
      prefix,
      prefix_len,
      types,
      count,
    );
  }

  late final _NT_GetTopicsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NT_Topic> Function(
              NT_Inst,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Size>)>>('NT_GetTopics');
  late final _NT_GetTopics = _NT_GetTopicsPtr.asFunction<
      ffi.Pointer<NT_Topic> Function(
          int, ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Size>)>();

  /// Get Published Topic Handles.
  ///
  /// Returns an array of topic handles.  The results are optionally
  /// filtered by string prefix and type to only return a subset of all
  /// topics.
  ///
  /// @param inst          instance handle
  /// @param prefix        name required prefix; only topics whose name
  /// starts with this string are returned
  /// @param prefix_len    length of prefix in bytes
  /// @param types         array of type strings
  /// @param types_len     number of elements in types array
  /// @param count         output parameter; set to length of returned array
  /// @return Array of topic handles.
  ffi.Pointer<NT_Topic> NT_GetTopicsStr(
    int inst,
    ffi.Pointer<ffi.Char> prefix,
    int prefix_len,
    ffi.Pointer<ffi.Pointer<ffi.Char>> types,
    int types_len,
    ffi.Pointer<ffi.Size> count,
  ) {
    return _NT_GetTopicsStr(
      inst,
      prefix,
      prefix_len,
      types,
      types_len,
      count,
    );
  }

  late final _NT_GetTopicsStrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NT_Topic> Function(
              NT_Inst,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Size,
              ffi.Pointer<ffi.Size>)>>('NT_GetTopicsStr');
  late final _NT_GetTopicsStr = _NT_GetTopicsStrPtr.asFunction<
      ffi.Pointer<NT_Topic> Function(int, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, int, ffi.Pointer<ffi.Size>)>();

  /// Get Topics.
  ///
  /// Returns an array of topic information (handle, name, type).  The results are
  /// optionally filtered by string prefix and type to only return a subset
  /// of all topics.
  ///
  /// @param inst          instance handle
  /// @param prefix        name required prefix; only topics whose name
  /// starts with this string are returned
  /// @param prefix_len    length of prefix in bytes
  /// @param types         bitmask of NT_Type values; 0 is treated specially
  /// as a "don't care"
  /// @param count         output parameter; set to length of returned array
  /// @return Array of topic information.
  ffi.Pointer<NT_TopicInfo> NT_GetTopicInfos(
    int inst,
    ffi.Pointer<ffi.Char> prefix,
    int prefix_len,
    int types,
    ffi.Pointer<ffi.Size> count,
  ) {
    return _NT_GetTopicInfos(
      inst,
      prefix,
      prefix_len,
      types,
      count,
    );
  }

  late final _NT_GetTopicInfosPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NT_TopicInfo> Function(
              NT_Inst,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Size>)>>('NT_GetTopicInfos');
  late final _NT_GetTopicInfos = _NT_GetTopicInfosPtr.asFunction<
      ffi.Pointer<NT_TopicInfo> Function(
          int, ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Size>)>();

  /// Get Topics.
  ///
  /// Returns an array of topic information (handle, name, type).  The results are
  /// optionally filtered by string prefix and type to only return a subset
  /// of all topics.
  ///
  /// @param inst          instance handle
  /// @param prefix        name required prefix; only topics whose name
  /// starts with this string are returned
  /// @param prefix_len    length of prefix in bytes
  /// @param types         array of type strings
  /// @param types_len     number of elements in types array
  /// @param count         output parameter; set to length of returned array
  /// @return Array of topic information.
  ffi.Pointer<NT_TopicInfo> NT_GetTopicInfosStr(
    int inst,
    ffi.Pointer<ffi.Char> prefix,
    int prefix_len,
    ffi.Pointer<ffi.Pointer<ffi.Char>> types,
    int types_len,
    ffi.Pointer<ffi.Size> count,
  ) {
    return _NT_GetTopicInfosStr(
      inst,
      prefix,
      prefix_len,
      types,
      types_len,
      count,
    );
  }

  late final _NT_GetTopicInfosStrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NT_TopicInfo> Function(
              NT_Inst,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Size,
              ffi.Pointer<ffi.Size>)>>('NT_GetTopicInfosStr');
  late final _NT_GetTopicInfosStr = _NT_GetTopicInfosStrPtr.asFunction<
      ffi.Pointer<NT_TopicInfo> Function(int, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, int, ffi.Pointer<ffi.Size>)>();

  /// Gets Topic Information.
  ///
  /// Returns information about a topic (name and type).
  ///
  /// @param topic         handle
  /// @param info          information (output)
  /// @return True if successful, false on error.
  int NT_GetTopicInfo(
    int topic,
    ffi.Pointer<NT_TopicInfo> info,
  ) {
    return _NT_GetTopicInfo(
      topic,
      info,
    );
  }

  late final _NT_GetTopicInfoPtr = _lookup<
      ffi.NativeFunction<
          NT_Bool Function(
              NT_Topic, ffi.Pointer<NT_TopicInfo>)>>('NT_GetTopicInfo');
  late final _NT_GetTopicInfo = _NT_GetTopicInfoPtr.asFunction<
      int Function(int, ffi.Pointer<NT_TopicInfo>)>();

  /// Gets Topic Handle.
  ///
  /// Returns topic handle.
  ///
  /// @param inst      instance handle
  /// @param name      topic name
  /// @param name_len  length of topic name in bytes
  /// @return Topic handle.
  int NT_GetTopic(
    int inst,
    ffi.Pointer<ffi.Char> name,
    int name_len,
  ) {
    return _NT_GetTopic(
      inst,
      name,
      name_len,
    );
  }

  late final _NT_GetTopicPtr = _lookup<
      ffi.NativeFunction<
          NT_Topic Function(
              NT_Inst, ffi.Pointer<ffi.Char>, ffi.Size)>>('NT_GetTopic');
  late final _NT_GetTopic = _NT_GetTopicPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// Gets the name of the specified topic.
  ///
  /// @param topic     topic handle
  /// @param name_len  length of topic name (output)
  /// @return Topic name; returns NULL and name_len=0 if the handle is invalid.
  ffi.Pointer<ffi.Char> NT_GetTopicName(
    int topic,
    ffi.Pointer<ffi.Size> name_len,
  ) {
    return _NT_GetTopicName(
      topic,
      name_len,
    );
  }

  late final _NT_GetTopicNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              NT_Topic, ffi.Pointer<ffi.Size>)>>('NT_GetTopicName');
  late final _NT_GetTopicName = _NT_GetTopicNamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Size>)>();

  /// Gets the type for the specified topic, or unassigned if non existent.
  ///
  /// @param topic   topic handle
  /// @return Topic type
  int NT_GetTopicType(
    int topic,
  ) {
    return _NT_GetTopicType(
      topic,
    );
  }

  late final _NT_GetTopicTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(NT_Topic)>>(
          'NT_GetTopicType');
  late final _NT_GetTopicType =
      _NT_GetTopicTypePtr.asFunction<int Function(int)>();

  /// Gets the type string for the specified topic.  This may have more information
  /// than the numeric type (especially for raw values).
  ///
  /// @param topic     topic handle
  /// @param type_len  length of type string (output)
  /// @return Topic type string; returns NULL if non-existent
  ffi.Pointer<ffi.Char> NT_GetTopicTypeString(
    int topic,
    ffi.Pointer<ffi.Size> type_len,
  ) {
    return _NT_GetTopicTypeString(
      topic,
      type_len,
    );
  }

  late final _NT_GetTopicTypeStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              NT_Topic, ffi.Pointer<ffi.Size>)>>('NT_GetTopicTypeString');
  late final _NT_GetTopicTypeString = _NT_GetTopicTypeStringPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Size>)>();

  /// Sets the persistent property of a topic.  If true, the stored value is
  /// persistent through server restarts.
  ///
  /// @param topic topic handle
  /// @param value True for persistent, false for not persistent.
  void NT_SetTopicPersistent(
    int topic,
    int value,
  ) {
    return _NT_SetTopicPersistent(
      topic,
      value,
    );
  }

  late final _NT_SetTopicPersistentPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Topic, NT_Bool)>>(
          'NT_SetTopicPersistent');
  late final _NT_SetTopicPersistent =
      _NT_SetTopicPersistentPtr.asFunction<void Function(int, int)>();

  /// Gets the persistent property of a topic.
  ///
  /// @param topic topic handle
  /// @return persistent property value
  int NT_GetTopicPersistent(
    int topic,
  ) {
    return _NT_GetTopicPersistent(
      topic,
    );
  }

  late final _NT_GetTopicPersistentPtr =
      _lookup<ffi.NativeFunction<NT_Bool Function(NT_Topic)>>(
          'NT_GetTopicPersistent');
  late final _NT_GetTopicPersistent =
      _NT_GetTopicPersistentPtr.asFunction<int Function(int)>();

  /// Sets the retained property of a topic.  If true, the server retains the
  /// topic even when there are no publishers.
  ///
  /// @param topic topic handle
  /// @param value new retained property value
  void NT_SetTopicRetained(
    int topic,
    int value,
  ) {
    return _NT_SetTopicRetained(
      topic,
      value,
    );
  }

  late final _NT_SetTopicRetainedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Topic, NT_Bool)>>(
          'NT_SetTopicRetained');
  late final _NT_SetTopicRetained =
      _NT_SetTopicRetainedPtr.asFunction<void Function(int, int)>();

  /// Gets the retained property of a topic.
  ///
  /// @param topic topic handle
  /// @return retained property value
  int NT_GetTopicRetained(
    int topic,
  ) {
    return _NT_GetTopicRetained(
      topic,
    );
  }

  late final _NT_GetTopicRetainedPtr =
      _lookup<ffi.NativeFunction<NT_Bool Function(NT_Topic)>>(
          'NT_GetTopicRetained');
  late final _NT_GetTopicRetained =
      _NT_GetTopicRetainedPtr.asFunction<int Function(int)>();

  /// Determine if topic exists (e.g. has at least one publisher).
  ///
  /// @param handle Topic, entry, or subscriber handle.
  /// @return True if topic exists.
  int NT_GetTopicExists(
    int handle,
  ) {
    return _NT_GetTopicExists(
      handle,
    );
  }

  late final _NT_GetTopicExistsPtr =
      _lookup<ffi.NativeFunction<NT_Bool Function(NT_Handle)>>(
          'NT_GetTopicExists');
  late final _NT_GetTopicExists =
      _NT_GetTopicExistsPtr.asFunction<int Function(int)>();

  /// Gets the current value of a property (as a JSON string).
  ///
  /// @param topic topic handle
  /// @param name property name
  /// @param len length of returned string (output)
  /// @return JSON string; empty string if the property does not exist.
  ffi.Pointer<ffi.Char> NT_GetTopicProperty(
    int topic,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Size> len,
  ) {
    return _NT_GetTopicProperty(
      topic,
      name,
      len,
    );
  }

  late final _NT_GetTopicPropertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(NT_Topic, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Size>)>>('NT_GetTopicProperty');
  late final _NT_GetTopicProperty = _NT_GetTopicPropertyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>();

  /// Sets a property value.
  ///
  /// @param topic topic handle
  /// @param name property name
  /// @param value property value (JSON string)
  int NT_SetTopicProperty(
    int topic,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _NT_SetTopicProperty(
      topic,
      name,
      value,
    );
  }

  late final _NT_SetTopicPropertyPtr = _lookup<
      ffi.NativeFunction<
          NT_Bool Function(NT_Topic, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('NT_SetTopicProperty');
  late final _NT_SetTopicProperty = _NT_SetTopicPropertyPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Deletes a property.  Has no effect if the property does not exist.
  ///
  /// @param topic topic handle
  /// @param name property name
  void NT_DeleteTopicProperty(
    int topic,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _NT_DeleteTopicProperty(
      topic,
      name,
    );
  }

  late final _NT_DeleteTopicPropertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              NT_Topic, ffi.Pointer<ffi.Char>)>>('NT_DeleteTopicProperty');
  late final _NT_DeleteTopicProperty = _NT_DeleteTopicPropertyPtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Gets all topic properties as a JSON string.  Each key in the object
  /// is the property name, and the corresponding value is the property value.
  ///
  /// @param topic topic handle
  /// @param len length of returned string (output)
  /// @return JSON string
  ffi.Pointer<ffi.Char> NT_GetTopicProperties(
    int topic,
    ffi.Pointer<ffi.Size> len,
  ) {
    return _NT_GetTopicProperties(
      topic,
      len,
    );
  }

  late final _NT_GetTopicPropertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              NT_Topic, ffi.Pointer<ffi.Size>)>>('NT_GetTopicProperties');
  late final _NT_GetTopicProperties = _NT_GetTopicPropertiesPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Size>)>();

  /// Updates multiple topic properties.  Each key in the passed-in JSON object is
  /// the name of the property to add/update, and the corresponding value is the
  /// property value to set for that property.  Null values result in deletion
  /// of the corresponding property.
  ///
  /// @param topic topic handle
  /// @param properties JSON object string with keys to add/update/delete
  /// @return False if properties are not a valid JSON object
  int NT_SetTopicProperties(
    int topic,
    ffi.Pointer<ffi.Char> properties,
  ) {
    return _NT_SetTopicProperties(
      topic,
      properties,
    );
  }

  late final _NT_SetTopicPropertiesPtr = _lookup<
      ffi.NativeFunction<
          NT_Bool Function(
              NT_Topic, ffi.Pointer<ffi.Char>)>>('NT_SetTopicProperties');
  late final _NT_SetTopicProperties = _NT_SetTopicPropertiesPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Creates a new subscriber to value changes on a topic.
  ///
  /// @param topic topic handle
  /// @param type expected type
  /// @param typeStr expected type string
  /// @param options subscription options
  /// @param options_len number of elements in options array
  /// @return Subscriber handle
  int NT_Subscribe(
    int topic,
    int type,
    ffi.Pointer<ffi.Char> typeStr,
    ffi.Pointer<NT_PubSubOption> options,
    int options_len,
  ) {
    return _NT_Subscribe(
      topic,
      type,
      typeStr,
      options,
      options_len,
    );
  }

  late final _NT_SubscribePtr = _lookup<
      ffi.NativeFunction<
          NT_Subscriber Function(NT_Topic, ffi.Int32, ffi.Pointer<ffi.Char>,
              ffi.Pointer<NT_PubSubOption>, ffi.Size)>>('NT_Subscribe');
  late final _NT_Subscribe = _NT_SubscribePtr.asFunction<
      int Function(int, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<NT_PubSubOption>, int)>();

  /// Stops subscriber.
  ///
  /// @param sub subscriber handle
  void NT_Unsubscribe(
    int sub,
  ) {
    return _NT_Unsubscribe(
      sub,
    );
  }

  late final _NT_UnsubscribePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Subscriber)>>(
          'NT_Unsubscribe');
  late final _NT_Unsubscribe =
      _NT_UnsubscribePtr.asFunction<void Function(int)>();

  /// Creates a new publisher to a topic.
  ///
  /// @param topic topic handle
  /// @param type type
  /// @param typeStr type string
  /// @param options publish options
  /// @param options_len number of elements in options array
  /// @return Publisher handle
  int NT_Publish(
    int topic,
    int type,
    ffi.Pointer<ffi.Char> typeStr,
    ffi.Pointer<NT_PubSubOption> options,
    int options_len,
  ) {
    return _NT_Publish(
      topic,
      type,
      typeStr,
      options,
      options_len,
    );
  }

  late final _NT_PublishPtr = _lookup<
      ffi.NativeFunction<
          NT_Publisher Function(NT_Topic, ffi.Int32, ffi.Pointer<ffi.Char>,
              ffi.Pointer<NT_PubSubOption>, ffi.Size)>>('NT_Publish');
  late final _NT_Publish = _NT_PublishPtr.asFunction<
      int Function(int, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<NT_PubSubOption>, int)>();

  /// Creates a new publisher to a topic.
  ///
  /// @param topic topic handle
  /// @param type type
  /// @param typeStr type string
  /// @param properties initial properties (JSON object)
  /// @param options publish options
  /// @param options_len number of elements in options array
  /// @return Publisher handle
  int NT_PublishEx(
    int topic,
    int type,
    ffi.Pointer<ffi.Char> typeStr,
    ffi.Pointer<ffi.Char> properties,
    ffi.Pointer<NT_PubSubOption> options,
    int options_len,
  ) {
    return _NT_PublishEx(
      topic,
      type,
      typeStr,
      properties,
      options,
      options_len,
    );
  }

  late final _NT_PublishExPtr = _lookup<
      ffi.NativeFunction<
          NT_Publisher Function(
              NT_Topic,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<NT_PubSubOption>,
              ffi.Size)>>('NT_PublishEx');
  late final _NT_PublishEx = _NT_PublishExPtr.asFunction<
      int Function(int, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<NT_PubSubOption>, int)>();

  /// Stops publisher.
  ///
  /// @param pubentry publisher/entry handle
  void NT_Unpublish(
    int pubentry,
  ) {
    return _NT_Unpublish(
      pubentry,
    );
  }

  late final _NT_UnpublishPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Handle)>>('NT_Unpublish');
  late final _NT_Unpublish = _NT_UnpublishPtr.asFunction<void Function(int)>();

  /// @brief Creates a new entry (subscriber and weak publisher) to a topic.
  ///
  /// @param topic topic handle
  /// @param type type
  /// @param typeStr type string
  /// @param options publish options
  /// @param options_len number of elements in options array
  /// @return Entry handle
  int NT_GetEntryEx(
    int topic,
    int type,
    ffi.Pointer<ffi.Char> typeStr,
    ffi.Pointer<NT_PubSubOption> options,
    int options_len,
  ) {
    return _NT_GetEntryEx(
      topic,
      type,
      typeStr,
      options,
      options_len,
    );
  }

  late final _NT_GetEntryExPtr = _lookup<
      ffi.NativeFunction<
          NT_Entry Function(NT_Topic, ffi.Int32, ffi.Pointer<ffi.Char>,
              ffi.Pointer<NT_PubSubOption>, ffi.Size)>>('NT_GetEntryEx');
  late final _NT_GetEntryEx = _NT_GetEntryExPtr.asFunction<
      int Function(int, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<NT_PubSubOption>, int)>();

  /// Stops entry subscriber/publisher.
  ///
  /// @param entry entry handle
  void NT_ReleaseEntry(
    int entry,
  ) {
    return _NT_ReleaseEntry(
      entry,
    );
  }

  late final _NT_ReleaseEntryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Entry)>>(
          'NT_ReleaseEntry');
  late final _NT_ReleaseEntry =
      _NT_ReleaseEntryPtr.asFunction<void Function(int)>();

  /// Stops entry/subscriber/publisher.
  ///
  /// @param pubsubentry entry/subscriber/publisher handle
  void NT_Release(
    int pubsubentry,
  ) {
    return _NT_Release(
      pubsubentry,
    );
  }

  late final _NT_ReleasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Handle)>>('NT_Release');
  late final _NT_Release = _NT_ReleasePtr.asFunction<void Function(int)>();

  /// Gets the topic handle from an entry/subscriber/publisher handle.
  ///
  /// @param pubsubentry entry/subscriber/publisher handle
  /// @return Topic handle
  int NT_GetTopicFromHandle(
    int pubsubentry,
  ) {
    return _NT_GetTopicFromHandle(
      pubsubentry,
    );
  }

  late final _NT_GetTopicFromHandlePtr =
      _lookup<ffi.NativeFunction<NT_Topic Function(NT_Handle)>>(
          'NT_GetTopicFromHandle');
  late final _NT_GetTopicFromHandle =
      _NT_GetTopicFromHandlePtr.asFunction<int Function(int)>();

  /// Subscribes to multiple topics based on one or more topic name prefixes. Can
  /// be used in combination with a Value Listener or ReadQueueValue() to get value
  /// changes across all matching topics.
  ///
  /// @param inst instance handle
  /// @param prefixes topic name prefixes
  /// @param prefixes_len number of elements in prefixes array
  /// @param options subscriber options
  /// @param options_len number of elements in options array
  /// @return subscriber handle
  int NT_SubscribeMultiple(
    int inst,
    ffi.Pointer<NT_String> prefixes,
    int prefixes_len,
    ffi.Pointer<NT_PubSubOption> options,
    int options_len,
  ) {
    return _NT_SubscribeMultiple(
      inst,
      prefixes,
      prefixes_len,
      options,
      options_len,
    );
  }

  late final _NT_SubscribeMultiplePtr = _lookup<
      ffi.NativeFunction<
          NT_MultiSubscriber Function(NT_Inst, ffi.Pointer<NT_String>, ffi.Size,
              ffi.Pointer<NT_PubSubOption>, ffi.Size)>>('NT_SubscribeMultiple');
  late final _NT_SubscribeMultiple = _NT_SubscribeMultiplePtr.asFunction<
      int Function(int, ffi.Pointer<NT_String>, int,
          ffi.Pointer<NT_PubSubOption>, int)>();

  /// Unsubscribes a multi-subscriber.
  ///
  /// @param sub multi-subscriber handle
  void NT_UnsubscribeMultiple(
    int sub,
  ) {
    return _NT_UnsubscribeMultiple(
      sub,
    );
  }

  late final _NT_UnsubscribeMultiplePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_MultiSubscriber)>>(
          'NT_UnsubscribeMultiple');
  late final _NT_UnsubscribeMultiple =
      _NT_UnsubscribeMultiplePtr.asFunction<void Function(int)>();

  /// Creates a listener poller.
  ///
  /// A poller provides a single queue of poll events.  Events linked to this
  /// poller (using NT_AddPolledXListener()) will be stored in the queue and
  /// must be collected by calling NT_ReadListenerQueue().
  /// The returned handle must be destroyed with NT_DestroyListenerPoller().
  ///
  /// @param inst      instance handle
  /// @return poller handle
  int NT_CreateListenerPoller(
    int inst,
  ) {
    return _NT_CreateListenerPoller(
      inst,
    );
  }

  late final _NT_CreateListenerPollerPtr =
      _lookup<ffi.NativeFunction<NT_ListenerPoller Function(NT_Inst)>>(
          'NT_CreateListenerPoller');
  late final _NT_CreateListenerPoller =
      _NT_CreateListenerPollerPtr.asFunction<int Function(int)>();

  /// Destroys a listener poller.  This will abort any blocked polling
  /// call and prevent additional events from being generated for this poller.
  ///
  /// @param poller    poller handle
  void NT_DestroyListenerPoller(
    int poller,
  ) {
    return _NT_DestroyListenerPoller(
      poller,
    );
  }

  late final _NT_DestroyListenerPollerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_ListenerPoller)>>(
          'NT_DestroyListenerPoller');
  late final _NT_DestroyListenerPoller =
      _NT_DestroyListenerPollerPtr.asFunction<void Function(int)>();

  /// Read notifications.
  ///
  /// @param poller    poller handle
  /// @param len       length of returned array (output)
  /// @return Array of events.  Returns NULL and len=0 if no events since last
  /// call.
  ffi.Pointer<NT_Event> NT_ReadListenerQueue(
    int poller,
    ffi.Pointer<ffi.Size> len,
  ) {
    return _NT_ReadListenerQueue(
      poller,
      len,
    );
  }

  late final _NT_ReadListenerQueuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NT_Event> Function(NT_ListenerPoller,
              ffi.Pointer<ffi.Size>)>>('NT_ReadListenerQueue');
  late final _NT_ReadListenerQueue = _NT_ReadListenerQueuePtr.asFunction<
      ffi.Pointer<NT_Event> Function(int, ffi.Pointer<ffi.Size>)>();

  /// Removes a listener.
  ///
  /// @param listener Listener handle to remove
  void NT_RemoveListener(
    int listener,
  ) {
    return _NT_RemoveListener(
      listener,
    );
  }

  late final _NT_RemoveListenerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Listener)>>(
          'NT_RemoveListener');
  late final _NT_RemoveListener =
      _NT_RemoveListenerPtr.asFunction<void Function(int)>();

  /// Wait for the listener queue to be empty. This is primarily useful
  /// for deterministic testing. This blocks until either the listener
  /// queue is empty (e.g. there are no more events that need to be passed along to
  /// callbacks or poll queues) or the timeout expires.
  ///
  /// @param handle  handle
  /// @param timeout timeout, in seconds. Set to 0 for non-blocking behavior, or a
  /// negative value to block indefinitely
  /// @return False if timed out, otherwise true.
  int NT_WaitForListenerQueue(
    int handle,
    double timeout,
  ) {
    return _NT_WaitForListenerQueue(
      handle,
      timeout,
    );
  }

  late final _NT_WaitForListenerQueuePtr =
      _lookup<ffi.NativeFunction<NT_Bool Function(NT_Handle, ffi.Double)>>(
          'NT_WaitForListenerQueue');
  late final _NT_WaitForListenerQueue =
      _NT_WaitForListenerQueuePtr.asFunction<int Function(int, double)>();

  /// Create a listener for changes to topics with names that start with
  /// the given prefix. This creates a corresponding internal subscriber with the
  /// lifetime of the listener.
  ///
  /// @param inst Instance handle
  /// @param prefix Topic name string prefix
  /// @param prefix_len Length of topic name string prefix
  /// @param mask Bitmask of NT_EventFlags values (only topic and value events will
  /// be generated)
  /// @param data Data passed to callback function
  /// @param callback Listener function
  /// @return Listener handle
  int NT_AddListenerSingle(
    int inst,
    ffi.Pointer<ffi.Char> prefix,
    int prefix_len,
    int mask,
    ffi.Pointer<ffi.Void> data,
    NT_ListenerCallback callback,
  ) {
    return _NT_AddListenerSingle(
      inst,
      prefix,
      prefix_len,
      mask,
      data,
      callback,
    );
  }

  late final _NT_AddListenerSinglePtr = _lookup<
      ffi.NativeFunction<
          NT_Listener Function(
              NT_Inst,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>,
              NT_ListenerCallback)>>('NT_AddListenerSingle');
  late final _NT_AddListenerSingle = _NT_AddListenerSinglePtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Void>,
          NT_ListenerCallback)>();

  /// Create a listener for changes to topics with names that start with any of
  /// the given prefixes. This creates a corresponding internal subscriber with the
  /// lifetime of the listener.
  ///
  /// @param inst Instance handle
  /// @param prefixes Topic name string prefixes
  /// @param prefixes_len Number of elements in prefixes array
  /// @param mask Bitmask of NT_EventFlags values (only topic and value events will
  /// be generated)
  /// @param data Data passed to callback function
  /// @param callback Listener function
  /// @return Listener handle
  int NT_AddListenerMultiple(
    int inst,
    ffi.Pointer<NT_String> prefixes,
    int prefixes_len,
    int mask,
    ffi.Pointer<ffi.Void> data,
    NT_ListenerCallback callback,
  ) {
    return _NT_AddListenerMultiple(
      inst,
      prefixes,
      prefixes_len,
      mask,
      data,
      callback,
    );
  }

  late final _NT_AddListenerMultiplePtr = _lookup<
      ffi.NativeFunction<
          NT_Listener Function(
              NT_Inst,
              ffi.Pointer<NT_String>,
              ffi.Size,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>,
              NT_ListenerCallback)>>('NT_AddListenerMultiple');
  late final _NT_AddListenerMultiple = _NT_AddListenerMultiplePtr.asFunction<
      int Function(int, ffi.Pointer<NT_String>, int, int, ffi.Pointer<ffi.Void>,
          NT_ListenerCallback)>();

  /// Create a listener.
  ///
  /// Some combinations of handle and mask have no effect:
  /// - connection and log message events are only generated on instances
  /// - topic and value events are only generated on non-instances
  ///
  /// Adding value and topic events on a topic will create a corresponding internal
  /// subscriber with the lifetime of the listener.
  ///
  /// Adding a log message listener through this function will only result in
  /// events at NT_LOG_INFO or higher; for more customized settings, use
  /// NT_AddLogger().
  ///
  /// @param handle Handle
  /// @param mask Bitmask of NT_EventFlags values
  /// @param data Data passed to callback function
  /// @param callback Listener function
  /// @return Listener handle
  int NT_AddListener(
    int handle,
    int mask,
    ffi.Pointer<ffi.Void> data,
    NT_ListenerCallback callback,
  ) {
    return _NT_AddListener(
      handle,
      mask,
      data,
      callback,
    );
  }

  late final _NT_AddListenerPtr = _lookup<
      ffi.NativeFunction<
          NT_Listener Function(NT_Handle, ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>, NT_ListenerCallback)>>('NT_AddListener');
  late final _NT_AddListener = _NT_AddListenerPtr.asFunction<
      int Function(int, int, ffi.Pointer<ffi.Void>, NT_ListenerCallback)>();

  /// Creates a polled topic listener. This creates a corresponding internal
  /// subscriber with the lifetime of the listener.
  /// The caller is responsible for calling NT_ReadListenerQueue() to poll.
  ///
  /// @param poller            poller handle
  /// @param prefix            UTF-8 string prefix
  /// @param prefix_len        Length of UTF-8 string prefix
  /// @param mask              NT_EventFlags bitmask (only topic and value events
  /// will be generated)
  /// @return Listener handle
  int NT_AddPolledListenerSingle(
    int poller,
    ffi.Pointer<ffi.Char> prefix,
    int prefix_len,
    int mask,
  ) {
    return _NT_AddPolledListenerSingle(
      poller,
      prefix,
      prefix_len,
      mask,
    );
  }

  late final _NT_AddPolledListenerSinglePtr = _lookup<
      ffi.NativeFunction<
          NT_Listener Function(NT_ListenerPoller, ffi.Pointer<ffi.Char>,
              ffi.Size, ffi.UnsignedInt)>>('NT_AddPolledListenerSingle');
  late final _NT_AddPolledListenerSingle = _NT_AddPolledListenerSinglePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int)>();

  /// Creates a polled topic listener. This creates a corresponding internal
  /// subscriber with the lifetime of the listener.
  /// The caller is responsible for calling NT_ReadListenerQueue() to poll.
  ///
  /// @param poller            poller handle
  /// @param prefixes          array of UTF-8 string prefixes
  /// @param prefixes_len      Length of prefixes array
  /// @param mask              NT_EventFlags bitmask (only topic and value events
  /// will be generated)
  /// @return Listener handle
  int NT_AddPolledListenerMultiple(
    int poller,
    ffi.Pointer<NT_String> prefixes,
    int prefixes_len,
    int mask,
  ) {
    return _NT_AddPolledListenerMultiple(
      poller,
      prefixes,
      prefixes_len,
      mask,
    );
  }

  late final _NT_AddPolledListenerMultiplePtr = _lookup<
      ffi.NativeFunction<
          NT_Listener Function(NT_ListenerPoller, ffi.Pointer<NT_String>,
              ffi.Size, ffi.UnsignedInt)>>('NT_AddPolledListenerMultiple');
  late final _NT_AddPolledListenerMultiple = _NT_AddPolledListenerMultiplePtr
      .asFunction<int Function(int, ffi.Pointer<NT_String>, int, int)>();

  /// Creates a polled listener.
  /// The caller is responsible for calling NT_ReadListenerQueue() to poll.
  ///
  /// Some combinations of handle and mask have no effect:
  /// - connection and log message events are only generated on instances
  /// - topic and value events are only generated on non-instances
  ///
  /// Adding value and topic events on a topic will create a corresponding internal
  /// subscriber with the lifetime of the listener.
  ///
  /// Adding a log message listener through this function will only result in
  /// events at NT_LOG_INFO or higher; for more customized settings, use
  /// NT_AddPolledLogger().
  ///
  /// @param poller            poller handle
  /// @param handle            handle
  /// @param mask              NT_NotifyKind bitmask
  /// @return Listener handle
  int NT_AddPolledListener(
    int poller,
    int handle,
    int mask,
  ) {
    return _NT_AddPolledListener(
      poller,
      handle,
      mask,
    );
  }

  late final _NT_AddPolledListenerPtr = _lookup<
      ffi.NativeFunction<
          NT_Listener Function(NT_ListenerPoller, NT_Handle,
              ffi.UnsignedInt)>>('NT_AddPolledListener');
  late final _NT_AddPolledListener =
      _NT_AddPolledListenerPtr.asFunction<int Function(int, int, int)>();

  /// Get the current network mode.
  ///
  /// @param inst  instance handle
  /// @return Bitmask of NT_NetworkMode.
  int NT_GetNetworkMode(
    int inst,
  ) {
    return _NT_GetNetworkMode(
      inst,
    );
  }

  late final _NT_GetNetworkModePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(NT_Inst)>>(
          'NT_GetNetworkMode');
  late final _NT_GetNetworkMode =
      _NT_GetNetworkModePtr.asFunction<int Function(int)>();

  /// Starts local-only operation.  Prevents calls to NT_StartServer or
  /// NT_StartClient from taking effect.  Has no effect if NT_StartServer or
  /// NT_StartClient has already been called.
  void NT_StartLocal(
    int inst,
  ) {
    return _NT_StartLocal(
      inst,
    );
  }

  late final _NT_StartLocalPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Inst)>>('NT_StartLocal');
  late final _NT_StartLocal =
      _NT_StartLocalPtr.asFunction<void Function(int)>();

  /// Stops local-only operation.  NT_StartServer or NT_StartClient can be called
  /// after this call to start a server or client.
  void NT_StopLocal(
    int inst,
  ) {
    return _NT_StopLocal(
      inst,
    );
  }

  late final _NT_StopLocalPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Inst)>>('NT_StopLocal');
  late final _NT_StopLocal = _NT_StopLocalPtr.asFunction<void Function(int)>();

  /// Starts a server using the specified filename, listening address, and port.
  ///
  /// @param inst              instance handle
  /// @param persist_filename  the name of the persist file to use (UTF-8 string,
  /// null terminated)
  /// @param listen_address    the address to listen on, or null to listen on any
  /// address. (UTF-8 string, null terminated)
  /// @param port3             port to communicate over (NT3)
  /// @param port4             port to communicate over (NT4)
  void NT_StartServer(
    int inst,
    ffi.Pointer<ffi.Char> persist_filename,
    ffi.Pointer<ffi.Char> listen_address,
    int port3,
    int port4,
  ) {
    return _NT_StartServer(
      inst,
      persist_filename,
      listen_address,
      port3,
      port4,
    );
  }

  late final _NT_StartServerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              NT_Inst,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('NT_StartServer');
  late final _NT_StartServer = _NT_StartServerPtr.asFunction<
      void Function(
          int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, int)>();

  /// Stops the server if it is running.
  ///
  /// @param inst  instance handle
  void NT_StopServer(
    int inst,
  ) {
    return _NT_StopServer(
      inst,
    );
  }

  late final _NT_StopServerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Inst)>>('NT_StopServer');
  late final _NT_StopServer =
      _NT_StopServerPtr.asFunction<void Function(int)>();

  /// Starts a NT3 client.  Use NT_SetServer or NT_SetServerTeam to set the server
  /// name and port.
  ///
  /// @param inst      instance handle
  /// @param identity  network identity to advertise (cannot be empty string)
  void NT_StartClient3(
    int inst,
    ffi.Pointer<ffi.Char> identity,
  ) {
    return _NT_StartClient3(
      inst,
      identity,
    );
  }

  late final _NT_StartClient3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              NT_Inst, ffi.Pointer<ffi.Char>)>>('NT_StartClient3');
  late final _NT_StartClient3 = _NT_StartClient3Ptr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Starts a NT4 client.  Use NT_SetServer or NT_SetServerTeam to set the server
  /// name and port.
  ///
  /// @param inst      instance handle
  /// @param identity  network identity to advertise (cannot be empty string)
  void NT_StartClient4(
    int inst,
    ffi.Pointer<ffi.Char> identity,
  ) {
    return _NT_StartClient4(
      inst,
      identity,
    );
  }

  late final _NT_StartClient4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              NT_Inst, ffi.Pointer<ffi.Char>)>>('NT_StartClient4');
  late final _NT_StartClient4 = _NT_StartClient4Ptr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Stops the client if it is running.
  ///
  /// @param inst  instance handle
  void NT_StopClient(
    int inst,
  ) {
    return _NT_StopClient(
      inst,
    );
  }

  late final _NT_StopClientPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Inst)>>('NT_StopClient');
  late final _NT_StopClient =
      _NT_StopClientPtr.asFunction<void Function(int)>();

  /// Sets server address and port for client (without restarting client).
  ///
  /// @param inst        instance handle
  /// @param server_name server name (UTF-8 string, null terminated)
  /// @param port        port to communicate over
  void NT_SetServer(
    int inst,
    ffi.Pointer<ffi.Char> server_name,
    int port,
  ) {
    return _NT_SetServer(
      inst,
      server_name,
      port,
    );
  }

  late final _NT_SetServerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(NT_Inst, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('NT_SetServer');
  late final _NT_SetServer = _NT_SetServerPtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// Sets server addresses for client (without restarting client).
  /// The client will attempt to connect to each server in round robin fashion.
  ///
  /// @param inst         instance handle
  /// @param count        length of the server_names and ports arrays
  /// @param server_names array of server names (each a UTF-8 string, null
  /// terminated)
  /// @param ports        array of ports to communicate over (one for each server)
  void NT_SetServerMulti(
    int inst,
    int count,
    ffi.Pointer<ffi.Pointer<ffi.Char>> server_names,
    ffi.Pointer<ffi.UnsignedInt> ports,
  ) {
    return _NT_SetServerMulti(
      inst,
      count,
      server_names,
      ports,
    );
  }

  late final _NT_SetServerMultiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              NT_Inst,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.UnsignedInt>)>>('NT_SetServerMulti');
  late final _NT_SetServerMulti = _NT_SetServerMultiPtr.asFunction<
      void Function(int, int, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Sets server addresses and port for client (without restarting client).
  /// Connects using commonly known robot addresses for the specified team.
  ///
  /// @param inst        instance handle
  /// @param team        team number
  /// @param port        port to communicate over
  void NT_SetServerTeam(
    int inst,
    int team,
    int port,
  ) {
    return _NT_SetServerTeam(
      inst,
      team,
      port,
    );
  }

  late final _NT_SetServerTeamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              NT_Inst, ffi.UnsignedInt, ffi.UnsignedInt)>>('NT_SetServerTeam');
  late final _NT_SetServerTeam =
      _NT_SetServerTeamPtr.asFunction<void Function(int, int, int)>();

  /// Starts requesting server address from Driver Station.
  /// This connects to the Driver Station running on localhost to obtain the
  /// server IP address.
  ///
  /// @param inst  instance handle
  /// @param port  server port to use in combination with IP from DS
  void NT_StartDSClient(
    int inst,
    int port,
  ) {
    return _NT_StartDSClient(
      inst,
      port,
    );
  }

  late final _NT_StartDSClientPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Inst, ffi.UnsignedInt)>>(
          'NT_StartDSClient');
  late final _NT_StartDSClient =
      _NT_StartDSClientPtr.asFunction<void Function(int, int)>();

  /// Stops requesting server address from Driver Station.
  ///
  /// @param inst  instance handle
  void NT_StopDSClient(
    int inst,
  ) {
    return _NT_StopDSClient(
      inst,
    );
  }

  late final _NT_StopDSClientPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Inst)>>(
          'NT_StopDSClient');
  late final _NT_StopDSClient =
      _NT_StopDSClientPtr.asFunction<void Function(int)>();

  /// Flush local updates.
  ///
  /// Forces an immediate flush of all local changes to the client/server.
  /// This does not flush to the network.
  ///
  /// Normally this is done on a regularly scheduled interval.
  ///
  /// @param inst      instance handle
  void NT_FlushLocal(
    int inst,
  ) {
    return _NT_FlushLocal(
      inst,
    );
  }

  late final _NT_FlushLocalPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Inst)>>('NT_FlushLocal');
  late final _NT_FlushLocal =
      _NT_FlushLocalPtr.asFunction<void Function(int)>();

  /// Flush to network.
  ///
  /// Forces an immediate flush of all local entry changes to network.
  /// Normally this is done on a regularly scheduled interval (set
  /// by update rates on individual publishers).
  ///
  /// Note: flushes are rate limited to avoid excessive network traffic.  If
  /// the time between calls is too short, the flush will occur after the minimum
  /// time elapses (rather than immediately).
  ///
  /// @param inst      instance handle
  void NT_Flush(
    int inst,
  ) {
    return _NT_Flush(
      inst,
    );
  }

  late final _NT_FlushPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NT_Inst)>>('NT_Flush');
  late final _NT_Flush = _NT_FlushPtr.asFunction<void Function(int)>();

  /// Get information on the currently established network connections.
  /// If operating as a client, this will return either zero or one values.
  ///
  /// @param inst  instance handle
  /// @param count returns the number of elements in the array
  /// @return      array of connection information
  ///
  /// It is the caller's responsibility to free the array. The
  /// NT_DisposeConnectionInfoArray function is useful for this purpose.
  ffi.Pointer<NT_ConnectionInfo> NT_GetConnections(
    int inst,
    ffi.Pointer<ffi.Size> count,
  ) {
    return _NT_GetConnections(
      inst,
      count,
    );
  }

  late final _NT_GetConnectionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NT_ConnectionInfo> Function(
              NT_Inst, ffi.Pointer<ffi.Size>)>>('NT_GetConnections');
  late final _NT_GetConnections = _NT_GetConnectionsPtr.asFunction<
      ffi.Pointer<NT_ConnectionInfo> Function(int, ffi.Pointer<ffi.Size>)>();

  /// Return whether or not the instance is connected to another node.
  ///
  /// @param inst  instance handle
  /// @return True if connected.
  int NT_IsConnected(
    int inst,
  ) {
    return _NT_IsConnected(
      inst,
    );
  }

  late final _NT_IsConnectedPtr =
      _lookup<ffi.NativeFunction<NT_Bool Function(NT_Inst)>>('NT_IsConnected');
  late final _NT_IsConnected =
      _NT_IsConnectedPtr.asFunction<int Function(int)>();

  /// Frees value memory.
  ///
  /// @param value   value to free
  void NT_DisposeValue(
    ffi.Pointer<NT_Value> value,
  ) {
    return _NT_DisposeValue(
      value,
    );
  }

  late final _NT_DisposeValuePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NT_Value>)>>(
          'NT_DisposeValue');
  late final _NT_DisposeValue =
      _NT_DisposeValuePtr.asFunction<void Function(ffi.Pointer<NT_Value>)>();

  /// Initializes a NT_Value.
  /// Sets type to NT_UNASSIGNED and clears rest of struct.
  ///
  /// @param value value to initialize
  void NT_InitValue(
    ffi.Pointer<NT_Value> value,
  ) {
    return _NT_InitValue(
      value,
    );
  }

  late final _NT_InitValuePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NT_Value>)>>(
          'NT_InitValue');
  late final _NT_InitValue =
      _NT_InitValuePtr.asFunction<void Function(ffi.Pointer<NT_Value>)>();

  /// Frees string memory.
  ///
  /// @param str   string to free
  void NT_DisposeString(
    ffi.Pointer<NT_String> str,
  ) {
    return _NT_DisposeString(
      str,
    );
  }

  late final _NT_DisposeStringPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NT_String>)>>(
          'NT_DisposeString');
  late final _NT_DisposeString =
      _NT_DisposeStringPtr.asFunction<void Function(ffi.Pointer<NT_String>)>();

  /// Initializes a NT_String.
  /// Sets length to zero and pointer to null.
  ///
  /// @param str   string to initialize
  void NT_InitString(
    ffi.Pointer<NT_String> str,
  ) {
    return _NT_InitString(
      str,
    );
  }

  late final _NT_InitStringPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NT_String>)>>(
          'NT_InitString');
  late final _NT_InitString =
      _NT_InitStringPtr.asFunction<void Function(ffi.Pointer<NT_String>)>();

  /// Frees an array of NT_Values.
  ///
  /// @param arr   pointer to the value array to free
  /// @param count number of elements in the array
  ///
  /// Note that the individual NT_Values in the array should NOT be
  /// freed before calling this. This function will free all the values
  /// individually.
  void NT_DisposeValueArray(
    ffi.Pointer<NT_Value> arr,
    int count,
  ) {
    return _NT_DisposeValueArray(
      arr,
      count,
    );
  }

  late final _NT_DisposeValueArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NT_Value>, ffi.Size)>>('NT_DisposeValueArray');
  late final _NT_DisposeValueArray = _NT_DisposeValueArrayPtr.asFunction<
      void Function(ffi.Pointer<NT_Value>, int)>();

  /// Disposes a connection info array.
  ///
  /// @param arr   pointer to the array to dispose
  /// @param count number of elements in the array
  void NT_DisposeConnectionInfoArray(
    ffi.Pointer<NT_ConnectionInfo> arr,
    int count,
  ) {
    return _NT_DisposeConnectionInfoArray(
      arr,
      count,
    );
  }

  late final _NT_DisposeConnectionInfoArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<NT_ConnectionInfo>,
              ffi.Size)>>('NT_DisposeConnectionInfoArray');
  late final _NT_DisposeConnectionInfoArray = _NT_DisposeConnectionInfoArrayPtr
      .asFunction<void Function(ffi.Pointer<NT_ConnectionInfo>, int)>();

  /// Disposes a topic info array.
  ///
  /// @param arr   pointer to the array to dispose
  /// @param count number of elements in the array
  void NT_DisposeTopicInfoArray(
    ffi.Pointer<NT_TopicInfo> arr,
    int count,
  ) {
    return _NT_DisposeTopicInfoArray(
      arr,
      count,
    );
  }

  late final _NT_DisposeTopicInfoArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<NT_TopicInfo>,
              ffi.Size)>>('NT_DisposeTopicInfoArray');
  late final _NT_DisposeTopicInfoArray = _NT_DisposeTopicInfoArrayPtr
      .asFunction<void Function(ffi.Pointer<NT_TopicInfo>, int)>();

  /// Disposes a single topic info (as returned by NT_GetTopicInfo).
  ///
  /// @param info  pointer to the info to dispose
  void NT_DisposeTopicInfo(
    ffi.Pointer<NT_TopicInfo> info,
  ) {
    return _NT_DisposeTopicInfo(
      info,
    );
  }

  late final _NT_DisposeTopicInfoPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NT_TopicInfo>)>>(
          'NT_DisposeTopicInfo');
  late final _NT_DisposeTopicInfo = _NT_DisposeTopicInfoPtr.asFunction<
      void Function(ffi.Pointer<NT_TopicInfo>)>();

  /// Disposes an event array.
  ///
  /// @param arr   pointer to the array to dispose
  /// @param count number of elements in the array
  void NT_DisposeEventArray(
    ffi.Pointer<NT_Event> arr,
    int count,
  ) {
    return _NT_DisposeEventArray(
      arr,
      count,
    );
  }

  late final _NT_DisposeEventArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NT_Event>, ffi.Size)>>('NT_DisposeEventArray');
  late final _NT_DisposeEventArray = _NT_DisposeEventArrayPtr.asFunction<
      void Function(ffi.Pointer<NT_Event>, int)>();

  /// Disposes a single event.
  ///
  /// @param event  pointer to the event to dispose
  void NT_DisposeEvent(
    ffi.Pointer<NT_Event> event,
  ) {
    return _NT_DisposeEvent(
      event,
    );
  }

  late final _NT_DisposeEventPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NT_Event>)>>(
          'NT_DisposeEvent');
  late final _NT_DisposeEvent =
      _NT_DisposeEventPtr.asFunction<void Function(ffi.Pointer<NT_Event>)>();

  /// Returns monotonic current time in 1 us increments.
  /// This is the same time base used for entry and connection timestamps.
  /// This function by default simply wraps WPI_Now(), but if NT_SetNow() is
  /// called, this function instead returns the value passed to NT_SetNow();
  /// this can be used to reduce overhead.
  ///
  /// @return Timestamp
  int NT_Now() {
    return _NT_Now();
  }

  late final _NT_NowPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function()>>('NT_Now');
  late final _NT_Now = _NT_NowPtr.asFunction<int Function()>();

  /// Sets the current timestamp used for timestamping values that do not
  /// provide a timestamp (e.g. a value of 0 is passed).  For consistency,
  /// it also results in NT_Now() returning the set value.  This should generally
  /// be used only if the overhead of calling WPI_Now() is a concern.
  /// If used, it should be called periodically with the value of WPI_Now().
  ///
  /// @param timestamp timestamp (1 us increments)
  void NT_SetNow(
    int timestamp,
  ) {
    return _NT_SetNow(
      timestamp,
    );
  }

  late final _NT_SetNowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint64)>>('NT_SetNow');
  late final _NT_SetNow = _NT_SetNowPtr.asFunction<void Function(int)>();

  /// Add logger callback function.  By default, log messages are sent to stderr;
  /// this function sends log messages to the provided callback function instead.
  /// The callback function will only be called for log messages with level
  /// greater than or equal to min_level and less than or equal to max_level;
  /// messages outside this range will be silently ignored.
  ///
  /// @param inst        instance handle
  /// @param min_level   minimum log level
  /// @param max_level   maximum log level
  /// @param data        data pointer to pass to func
  /// @param func        listener callback function
  /// @return Listener handle
  int NT_AddLogger(
    int inst,
    int min_level,
    int max_level,
    ffi.Pointer<ffi.Void> data,
    NT_ListenerCallback func,
  ) {
    return _NT_AddLogger(
      inst,
      min_level,
      max_level,
      data,
      func,
    );
  }

  late final _NT_AddLoggerPtr = _lookup<
      ffi.NativeFunction<
          NT_Listener Function(NT_Inst, ffi.UnsignedInt, ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>, NT_ListenerCallback)>>('NT_AddLogger');
  late final _NT_AddLogger = _NT_AddLoggerPtr.asFunction<
      int Function(
          int, int, int, ffi.Pointer<ffi.Void>, NT_ListenerCallback)>();

  /// Set the log level for a listener poller.  Events will only be generated for
  /// log messages with level greater than or equal to min_level and less than or
  /// equal to max_level; messages outside this range will be silently ignored.
  ///
  /// @param poller        poller handle
  /// @param min_level     minimum log level
  /// @param max_level     maximum log level
  /// @return Listener handle
  int NT_AddPolledLogger(
    int poller,
    int min_level,
    int max_level,
  ) {
    return _NT_AddPolledLogger(
      poller,
      min_level,
      max_level,
    );
  }

  late final _NT_AddPolledLoggerPtr = _lookup<
      ffi.NativeFunction<
          NT_Listener Function(NT_ListenerPoller, ffi.UnsignedInt,
              ffi.UnsignedInt)>>('NT_AddPolledLogger');
  late final _NT_AddPolledLogger =
      _NT_AddPolledLoggerPtr.asFunction<int Function(int, int, int)>();

  /// Allocates an array of chars.
  /// Note that the size is the number of elements, and not the
  /// specific number of bytes to allocate. That is calculated internally.
  ///
  /// @param size  the number of elements the array will contain
  /// @return      the allocated char array
  ///
  /// After use, the array should be freed using the NT_FreeCharArray()
  /// function.
  ffi.Pointer<ffi.Char> NT_AllocateCharArray(
    int size,
  ) {
    return _NT_AllocateCharArray(
      size,
    );
  }

  late final _NT_AllocateCharArrayPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Size)>>(
          'NT_AllocateCharArray');
  late final _NT_AllocateCharArray = _NT_AllocateCharArrayPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int)>();

  /// Allocates an array of booleans.
  /// Note that the size is the number of elements, and not the
  /// specific number of bytes to allocate. That is calculated internally.
  ///
  /// @param size  the number of elements the array will contain
  /// @return      the allocated boolean array
  ///
  /// After use, the array should be freed using the NT_FreeBooleanArray()
  /// function.
  ffi.Pointer<NT_Bool> NT_AllocateBooleanArray(
    int size,
  ) {
    return _NT_AllocateBooleanArray(
      size,
    );
  }

  late final _NT_AllocateBooleanArrayPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NT_Bool> Function(ffi.Size)>>(
          'NT_AllocateBooleanArray');
  late final _NT_AllocateBooleanArray = _NT_AllocateBooleanArrayPtr.asFunction<
      ffi.Pointer<NT_Bool> Function(int)>();

  /// Allocates an array of ints.
  /// Note that the size is the number of elements, and not the
  /// specific number of bytes to allocate. That is calculated internally.
  ///
  /// @param size  the number of elements the array will contain
  /// @return      the allocated double array
  ///
  /// After use, the array should be freed using the NT_FreeIntArray()
  /// function.
  ffi.Pointer<ffi.Int64> NT_AllocateIntegerArray(
    int size,
  ) {
    return _NT_AllocateIntegerArray(
      size,
    );
  }

  late final _NT_AllocateIntegerArrayPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int64> Function(ffi.Size)>>(
          'NT_AllocateIntegerArray');
  late final _NT_AllocateIntegerArray = _NT_AllocateIntegerArrayPtr.asFunction<
      ffi.Pointer<ffi.Int64> Function(int)>();

  /// Allocates an array of floats.
  /// Note that the size is the number of elements, and not the
  /// specific number of bytes to allocate. That is calculated internally.
  ///
  /// @param size  the number of elements the array will contain
  /// @return      the allocated double array
  ///
  /// After use, the array should be freed using the NT_FreeFloatArray()
  /// function.
  ffi.Pointer<ffi.Float> NT_AllocateFloatArray(
    int size,
  ) {
    return _NT_AllocateFloatArray(
      size,
    );
  }

  late final _NT_AllocateFloatArrayPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Float> Function(ffi.Size)>>(
          'NT_AllocateFloatArray');
  late final _NT_AllocateFloatArray = _NT_AllocateFloatArrayPtr.asFunction<
      ffi.Pointer<ffi.Float> Function(int)>();

  /// Allocates an array of doubles.
  /// Note that the size is the number of elements, and not the
  /// specific number of bytes to allocate. That is calculated internally.
  ///
  /// @param size  the number of elements the array will contain
  /// @return      the allocated double array
  ///
  /// After use, the array should be freed using the NT_FreeDoubleArray()
  /// function.
  ffi.Pointer<ffi.Double> NT_AllocateDoubleArray(
    int size,
  ) {
    return _NT_AllocateDoubleArray(
      size,
    );
  }

  late final _NT_AllocateDoubleArrayPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Double> Function(ffi.Size)>>(
          'NT_AllocateDoubleArray');
  late final _NT_AllocateDoubleArray = _NT_AllocateDoubleArrayPtr.asFunction<
      ffi.Pointer<ffi.Double> Function(int)>();

  /// Allocates an array of NT_Strings.
  /// Note that the size is the number of elements, and not the
  /// specific number of bytes to allocate. That is calculated internally.
  ///
  /// @param size  the number of elements the array will contain
  /// @return      the allocated NT_String array
  ///
  /// After use, the array should be freed using the NT_FreeStringArray()
  /// function.
  ffi.Pointer<NT_String> NT_AllocateStringArray(
    int size,
  ) {
    return _NT_AllocateStringArray(
      size,
    );
  }

  late final _NT_AllocateStringArrayPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NT_String> Function(ffi.Size)>>(
          'NT_AllocateStringArray');
  late final _NT_AllocateStringArray = _NT_AllocateStringArrayPtr.asFunction<
      ffi.Pointer<NT_String> Function(int)>();

  /// Frees an array of chars.
  ///
  /// @param v_char pointer to the char array to free
  void NT_FreeCharArray(
    ffi.Pointer<ffi.Char> v_char,
  ) {
    return _NT_FreeCharArray(
      v_char,
    );
  }

  late final _NT_FreeCharArrayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'NT_FreeCharArray');
  late final _NT_FreeCharArray =
      _NT_FreeCharArrayPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// Frees an array of booleans.
  ///
  /// @param v_boolean pointer to the boolean array to free
  void NT_FreeBooleanArray(
    ffi.Pointer<NT_Bool> v_boolean,
  ) {
    return _NT_FreeBooleanArray(
      v_boolean,
    );
  }

  late final _NT_FreeBooleanArrayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NT_Bool>)>>(
          'NT_FreeBooleanArray');
  late final _NT_FreeBooleanArray =
      _NT_FreeBooleanArrayPtr.asFunction<void Function(ffi.Pointer<NT_Bool>)>();

  /// Frees an array of ints.
  ///
  /// @param v_int pointer to the int array to free
  void NT_FreeIntegerArray(
    ffi.Pointer<ffi.Int64> v_int,
  ) {
    return _NT_FreeIntegerArray(
      v_int,
    );
  }

  late final _NT_FreeIntegerArrayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int64>)>>(
          'NT_FreeIntegerArray');
  late final _NT_FreeIntegerArray = _NT_FreeIntegerArrayPtr.asFunction<
      void Function(ffi.Pointer<ffi.Int64>)>();

  /// Frees an array of floats.
  ///
  /// @param v_float pointer to the float array to free
  void NT_FreeFloatArray(
    ffi.Pointer<ffi.Float> v_float,
  ) {
    return _NT_FreeFloatArray(
      v_float,
    );
  }

  late final _NT_FreeFloatArrayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>(
          'NT_FreeFloatArray');
  late final _NT_FreeFloatArray =
      _NT_FreeFloatArrayPtr.asFunction<void Function(ffi.Pointer<ffi.Float>)>();

  /// Frees an array of doubles.
  ///
  /// @param v_double pointer to the double array to free
  void NT_FreeDoubleArray(
    ffi.Pointer<ffi.Double> v_double,
  ) {
    return _NT_FreeDoubleArray(
      v_double,
    );
  }

  late final _NT_FreeDoubleArrayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Double>)>>(
          'NT_FreeDoubleArray');
  late final _NT_FreeDoubleArray = _NT_FreeDoubleArrayPtr.asFunction<
      void Function(ffi.Pointer<ffi.Double>)>();

  /// Frees an array of NT_Strings.
  ///
  /// @param v_string  pointer to the string array to free
  /// @param arr_size  size of the string array to free
  ///
  /// Note that the individual NT_Strings in the array should NOT be
  /// freed before calling this. This function will free all the strings
  /// individually.
  void NT_FreeStringArray(
    ffi.Pointer<NT_String> v_string,
    int arr_size,
  ) {
    return _NT_FreeStringArray(
      v_string,
      arr_size,
    );
  }

  late final _NT_FreeStringArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NT_String>, ffi.Size)>>('NT_FreeStringArray');
  late final _NT_FreeStringArray = _NT_FreeStringArrayPtr.asFunction<
      void Function(ffi.Pointer<NT_String>, int)>();

  /// Returns the type of an NT_Value struct.
  /// Note that one of the type options is "unassigned".
  ///
  /// @param value  The NT_Value struct to get the type from.
  /// @return       The type of the value, or unassigned if null.
  int NT_GetValueType(
    ffi.Pointer<NT_Value> value,
  ) {
    return _NT_GetValueType(
      value,
    );
  }

  late final _NT_GetValueTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<NT_Value>)>>(
          'NT_GetValueType');
  late final _NT_GetValueType =
      _NT_GetValueTypePtr.asFunction<int Function(ffi.Pointer<NT_Value>)>();

  /// Returns the boolean from the NT_Value.
  /// If the NT_Value is null, or is assigned to a different type, returns 0.
  ///
  /// @param value       NT_Value struct to get the boolean from
  /// @param last_change returns time in ms since the last change in the value
  /// @param v_boolean   returns the boolean assigned to the name
  /// @return            1 if successful, or 0 if value is null or not a boolean
  int NT_GetValueBoolean(
    ffi.Pointer<NT_Value> value,
    ffi.Pointer<ffi.Uint64> last_change,
    ffi.Pointer<NT_Bool> v_boolean,
  ) {
    return _NT_GetValueBoolean(
      value,
      last_change,
      v_boolean,
    );
  }

  late final _NT_GetValueBooleanPtr = _lookup<
      ffi.NativeFunction<
          NT_Bool Function(ffi.Pointer<NT_Value>, ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<NT_Bool>)>>('NT_GetValueBoolean');
  late final _NT_GetValueBoolean = _NT_GetValueBooleanPtr.asFunction<
      int Function(ffi.Pointer<NT_Value>, ffi.Pointer<ffi.Uint64>,
          ffi.Pointer<NT_Bool>)>();

  /// Returns the int from the NT_Value.
  /// If the NT_Value is null, or is assigned to a different type, returns 0.
  ///
  /// @param value       NT_Value struct to get the int from
  /// @param last_change returns time in ms since the last change in the value
  /// @param v_int       returns the int assigned to the name
  /// @return            1 if successful, or 0 if value is null or not an int
  int NT_GetValueInteger(
    ffi.Pointer<NT_Value> value,
    ffi.Pointer<ffi.Uint64> last_change,
    ffi.Pointer<ffi.Int64> v_int,
  ) {
    return _NT_GetValueInteger(
      value,
      last_change,
      v_int,
    );
  }

  late final _NT_GetValueIntegerPtr = _lookup<
      ffi.NativeFunction<
          NT_Bool Function(ffi.Pointer<NT_Value>, ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Int64>)>>('NT_GetValueInteger');
  late final _NT_GetValueInteger = _NT_GetValueIntegerPtr.asFunction<
      int Function(ffi.Pointer<NT_Value>, ffi.Pointer<ffi.Uint64>,
          ffi.Pointer<ffi.Int64>)>();

  /// Returns the float from the NT_Value.
  /// If the NT_Value is null, or is assigned to a different type, returns 0.
  ///
  /// @param value       NT_Value struct to get the float from
  /// @param last_change returns time in ms since the last change in the value
  /// @param v_float     returns the float assigned to the name
  /// @return            1 if successful, or 0 if value is null or not a float
  int NT_GetValueFloat(
    ffi.Pointer<NT_Value> value,
    ffi.Pointer<ffi.Uint64> last_change,
    ffi.Pointer<ffi.Float> v_float,
  ) {
    return _NT_GetValueFloat(
      value,
      last_change,
      v_float,
    );
  }

  late final _NT_GetValueFloatPtr = _lookup<
      ffi.NativeFunction<
          NT_Bool Function(ffi.Pointer<NT_Value>, ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Float>)>>('NT_GetValueFloat');
  late final _NT_GetValueFloat = _NT_GetValueFloatPtr.asFunction<
      int Function(ffi.Pointer<NT_Value>, ffi.Pointer<ffi.Uint64>,
          ffi.Pointer<ffi.Float>)>();

  /// Returns the double from the NT_Value.
  /// If the NT_Value is null, or is assigned to a different type, returns 0.
  ///
  /// @param value       NT_Value struct to get the double from
  /// @param last_change returns time in ms since the last change in the value
  /// @param v_double    returns the double assigned to the name
  /// @return            1 if successful, or 0 if value is null or not a double
  int NT_GetValueDouble(
    ffi.Pointer<NT_Value> value,
    ffi.Pointer<ffi.Uint64> last_change,
    ffi.Pointer<ffi.Double> v_double,
  ) {
    return _NT_GetValueDouble(
      value,
      last_change,
      v_double,
    );
  }

  late final _NT_GetValueDoublePtr = _lookup<
      ffi.NativeFunction<
          NT_Bool Function(ffi.Pointer<NT_Value>, ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Double>)>>('NT_GetValueDouble');
  late final _NT_GetValueDouble = _NT_GetValueDoublePtr.asFunction<
      int Function(ffi.Pointer<NT_Value>, ffi.Pointer<ffi.Uint64>,
          ffi.Pointer<ffi.Double>)>();

  /// Returns a copy of the string from the NT_Value.
  /// If the NT_Value is null, or is assigned to a different type, returns 0.
  ///
  /// @param value       NT_Value struct to get the string from
  /// @param last_change returns time in ms since the last change in the value
  /// @param str_len     returns the length of the string
  /// @return            pointer to the string (UTF-8), or null if error
  ///
  /// It is the caller's responsibility to free the string once its no longer
  /// needed. The NT_FreeCharArray() function is useful for this purpose. The
  /// returned string is a copy of the string in the value, and must be freed
  /// separately.
  ffi.Pointer<ffi.Char> NT_GetValueString(
    ffi.Pointer<NT_Value> value,
    ffi.Pointer<ffi.Uint64> last_change,
    ffi.Pointer<ffi.Size> str_len,
  ) {
    return _NT_GetValueString(
      value,
      last_change,
      str_len,
    );
  }

  late final _NT_GetValueStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<NT_Value>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Size>)>>('NT_GetValueString');
  late final _NT_GetValueString = _NT_GetValueStringPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<NT_Value>,
          ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Size>)>();

  /// Returns a copy of the raw value from the NT_Value.
  /// If the NT_Value is null, or is assigned to a different type, returns null.
  ///
  /// @param value       NT_Value struct to get the string from
  /// @param last_change returns time in ms since the last change in the value
  /// @param raw_len     returns the length of the string
  /// @return            pointer to the raw value (UTF-8), or null if error
  ///
  /// It is the caller's responsibility to free the raw value once its no longer
  /// needed. The NT_FreeCharArray() function is useful for this purpose. The
  /// returned string is a copy of the string in the value, and must be freed
  /// separately.
  ffi.Pointer<ffi.Uint8> NT_GetValueRaw(
    ffi.Pointer<NT_Value> value,
    ffi.Pointer<ffi.Uint64> last_change,
    ffi.Pointer<ffi.Size> raw_len,
  ) {
    return _NT_GetValueRaw(
      value,
      last_change,
      raw_len,
    );
  }

  late final _NT_GetValueRawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<NT_Value>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Size>)>>('NT_GetValueRaw');
  late final _NT_GetValueRaw = _NT_GetValueRawPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<NT_Value>,
          ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Size>)>();

  /// Returns a copy of the boolean array from the NT_Value.
  /// If the NT_Value is null, or is assigned to a different type, returns null.
  ///
  /// @param value       NT_Value struct to get the boolean array from
  /// @param last_change returns time in ms since the last change in the value
  /// @param arr_size    returns the number of elements in the array
  /// @return            pointer to the boolean array, or null if error
  ///
  /// It is the caller's responsibility to free the array once its no longer
  /// needed. The NT_FreeBooleanArray() function is useful for this purpose.
  /// The returned array is a copy of the array in the value, and must be
  /// freed separately.
  ffi.Pointer<NT_Bool> NT_GetValueBooleanArray(
    ffi.Pointer<NT_Value> value,
    ffi.Pointer<ffi.Uint64> last_change,
    ffi.Pointer<ffi.Size> arr_size,
  ) {
    return _NT_GetValueBooleanArray(
      value,
      last_change,
      arr_size,
    );
  }

  late final _NT_GetValueBooleanArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NT_Bool> Function(
              ffi.Pointer<NT_Value>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Size>)>>('NT_GetValueBooleanArray');
  late final _NT_GetValueBooleanArray = _NT_GetValueBooleanArrayPtr.asFunction<
      ffi.Pointer<NT_Bool> Function(ffi.Pointer<NT_Value>,
          ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Size>)>();

  /// Returns a copy of the int array from the NT_Value.
  /// If the NT_Value is null, or is assigned to a different type, returns null.
  ///
  /// @param value       NT_Value struct to get the int array from
  /// @param last_change returns time in ms since the last change in the value
  /// @param arr_size    returns the number of elements in the array
  /// @return            pointer to the int array, or null if error
  ///
  /// It is the caller's responsibility to free the array once its no longer
  /// needed. The NT_FreeIntArray() function is useful for this purpose.
  /// The returned array is a copy of the array in the value, and must be
  /// freed separately.
  ffi.Pointer<ffi.Int64> NT_GetValueIntegerArray(
    ffi.Pointer<NT_Value> value,
    ffi.Pointer<ffi.Uint64> last_change,
    ffi.Pointer<ffi.Size> arr_size,
  ) {
    return _NT_GetValueIntegerArray(
      value,
      last_change,
      arr_size,
    );
  }

  late final _NT_GetValueIntegerArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int64> Function(
              ffi.Pointer<NT_Value>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Size>)>>('NT_GetValueIntegerArray');
  late final _NT_GetValueIntegerArray = _NT_GetValueIntegerArrayPtr.asFunction<
      ffi.Pointer<ffi.Int64> Function(ffi.Pointer<NT_Value>,
          ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Size>)>();

  /// Returns a copy of the float array from the NT_Value.
  /// If the NT_Value is null, or is assigned to a different type, returns null.
  ///
  /// @param value       NT_Value struct to get the float array from
  /// @param last_change returns time in ms since the last change in the value
  /// @param arr_size    returns the number of elements in the array
  /// @return            pointer to the float array, or null if error
  ///
  /// It is the caller's responsibility to free the array once its no longer
  /// needed. The NT_FreeFloatArray() function is useful for this purpose.
  /// The returned array is a copy of the array in the value, and must be
  /// freed separately.
  ffi.Pointer<ffi.Float> NT_GetValueFloatArray(
    ffi.Pointer<NT_Value> value,
    ffi.Pointer<ffi.Uint64> last_change,
    ffi.Pointer<ffi.Size> arr_size,
  ) {
    return _NT_GetValueFloatArray(
      value,
      last_change,
      arr_size,
    );
  }

  late final _NT_GetValueFloatArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Float> Function(
              ffi.Pointer<NT_Value>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Size>)>>('NT_GetValueFloatArray');
  late final _NT_GetValueFloatArray = _NT_GetValueFloatArrayPtr.asFunction<
      ffi.Pointer<ffi.Float> Function(ffi.Pointer<NT_Value>,
          ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Size>)>();

  /// Returns a copy of the double array from the NT_Value.
  /// If the NT_Value is null, or is assigned to a different type, returns null.
  ///
  /// @param value       NT_Value struct to get the double array from
  /// @param last_change returns time in ms since the last change in the value
  /// @param arr_size    returns the number of elements in the array
  /// @return            pointer to the double array, or null if error
  ///
  /// It is the caller's responsibility to free the array once its no longer
  /// needed. The NT_FreeDoubleArray() function is useful for this purpose.
  /// The returned array is a copy of the array in the value, and must be
  /// freed separately.
  ffi.Pointer<ffi.Double> NT_GetValueDoubleArray(
    ffi.Pointer<NT_Value> value,
    ffi.Pointer<ffi.Uint64> last_change,
    ffi.Pointer<ffi.Size> arr_size,
  ) {
    return _NT_GetValueDoubleArray(
      value,
      last_change,
      arr_size,
    );
  }

  late final _NT_GetValueDoubleArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Double> Function(
              ffi.Pointer<NT_Value>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Size>)>>('NT_GetValueDoubleArray');
  late final _NT_GetValueDoubleArray = _NT_GetValueDoubleArrayPtr.asFunction<
      ffi.Pointer<ffi.Double> Function(ffi.Pointer<NT_Value>,
          ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Size>)>();

  /// Returns a copy of the NT_String array from the NT_Value.
  /// If the NT_Value is null, or is assigned to a different type, returns null.
  ///
  /// @param value       NT_Value struct to get the NT_String array from
  /// @param last_change returns time in ms since the last change in the value
  /// @param arr_size    returns the number of elements in the array
  /// @return            pointer to the NT_String array, or null if error
  ///
  /// It is the caller's responsibility to free the array once its no longer
  /// needed. The NT_FreeStringArray() function is useful for this purpose.
  /// The returned array is a copy of the array in the value, and must be
  /// freed separately. Note that the individual NT_Strings should not be freed,
  /// but the entire array should be freed at once. The NT_FreeStringArray()
  /// function will free all the NT_Strings.
  ffi.Pointer<NT_String> NT_GetValueStringArray(
    ffi.Pointer<NT_Value> value,
    ffi.Pointer<ffi.Uint64> last_change,
    ffi.Pointer<ffi.Size> arr_size,
  ) {
    return _NT_GetValueStringArray(
      value,
      last_change,
      arr_size,
    );
  }

  late final _NT_GetValueStringArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NT_String> Function(
              ffi.Pointer<NT_Value>,
              ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Size>)>>('NT_GetValueStringArray');
  late final _NT_GetValueStringArray = _NT_GetValueStringArrayPtr.asFunction<
      ffi.Pointer<NT_String> Function(ffi.Pointer<NT_Value>,
          ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Size>)>();

  late final ffi.Pointer<ffi.Int> _wpi = _lookup<ffi.Int>('wpi');

  int get wpi => _wpi.value;

  set wpi(int value) => _wpi.value = value;
}

class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

/// NetworkTables data types.
abstract class NT_Type {
  static const int NT_UNASSIGNED = 0;
  static const int NT_BOOLEAN = 1;
  static const int NT_DOUBLE = 2;
  static const int NT_STRING = 4;
  static const int NT_RAW = 8;
  static const int NT_BOOLEAN_ARRAY = 16;
  static const int NT_DOUBLE_ARRAY = 32;
  static const int NT_STRING_ARRAY = 64;
  static const int NT_RPC = 128;
  static const int NT_INTEGER = 256;
  static const int NT_FLOAT = 512;
  static const int NT_INTEGER_ARRAY = 1024;
  static const int NT_FLOAT_ARRAY = 2048;
}

/// NetworkTables entry flags.
abstract class NT_EntryFlags {
  static const int NT_PERSISTENT = 1;
  static const int NT_RETAINED = 2;
}

/// NetworkTables logging levels.
abstract class NT_LogLevel {
  static const int NT_LOG_CRITICAL = 50;
  static const int NT_LOG_ERROR = 40;
  static const int NT_LOG_WARNING = 30;
  static const int NT_LOG_INFO = 20;
  static const int NT_LOG_DEBUG = 10;
  static const int NT_LOG_DEBUG1 = 9;
  static const int NT_LOG_DEBUG2 = 8;
  static const int NT_LOG_DEBUG3 = 7;
  static const int NT_LOG_DEBUG4 = 6;
}

/// Client/server modes
abstract class NT_NetworkMode {
  static const int NT_NET_MODE_NONE = 0;
  static const int NT_NET_MODE_SERVER = 1;
  static const int NT_NET_MODE_CLIENT3 = 2;
  static const int NT_NET_MODE_CLIENT4 = 4;
  static const int NT_NET_MODE_STARTING = 8;
  static const int NT_NET_MODE_LOCAL = 16;
}

/// Pub/sub option types
abstract class NT_PubSubOptionType {
  static const int NT_PUBSUB_PERIODIC = 1;
  static const int NT_PUBSUB_SENDALL = 2;
  static const int NT_PUBSUB_TOPICSONLY = 3;
  static const int NT_PUBSUB_POLLSTORAGE = 4;
  static const int NT_PUBSUB_KEEPDUPLICATES = 5;
}

/// Event notification flags.
abstract class NT_EventFlags {
  static const int NT_EVENT_NONE = 0;

  /// Initial listener addition.
  static const int NT_EVENT_IMMEDIATE = 1;

  /// Client connected (on server, any client connected).
  static const int NT_EVENT_CONNECTED = 2;

  /// Client disconnected (on server, any client disconnected).
  static const int NT_EVENT_DISCONNECTED = 4;

  /// Any connection event (connect or disconnect).
  static const int NT_EVENT_CONNECTION = 6;

  /// New topic published.
  static const int NT_EVENT_PUBLISH = 8;

  /// Topic unpublished.
  static const int NT_EVENT_UNPUBLISH = 16;

  /// Topic properties changed.
  static const int NT_EVENT_PROPERTIES = 32;

  /// Any topic event (publish, unpublish, or properties changed).
  static const int NT_EVENT_TOPIC = 56;

  /// Topic value updated (via network).
  static const int NT_EVENT_VALUE_REMOTE = 64;

  /// Topic value updated (local).
  static const int NT_EVENT_VALUE_LOCAL = 128;

  /// Topic value updated (network or local).
  static const int NT_EVENT_VALUE_ALL = 192;

  /// Log message.
  static const int NT_EVENT_LOGMESSAGE = 256;
}

/// A NetworkTables string.
class NT_String extends ffi.Struct {
  /// String contents (UTF-8).
  /// The string is NOT required to be zero-terminated.
  /// When returned by the library, this is zero-terminated and allocated with
  /// std::malloc().
  external ffi.Pointer<ffi.Char> str;

  /// Length of the string in bytes.  If the string happens to be zero
  /// terminated, this does not include the zero-termination.
  @ffi.Size()
  external int len;
}

/// NetworkTables Entry Value.  Note this is a typed union.
class NT_Value extends ffi.Struct {
  @ffi.Int32()
  external int type;

  @ffi.Int64()
  external int last_change;

  @ffi.Int64()
  external int server_time;

  external UnnamedUnion1 data;
}

class UnnamedUnion1 extends ffi.Union {
  @NT_Bool()
  external int v_boolean;

  @ffi.Int64()
  external int v_int;

  @ffi.Float()
  external double v_float;

  @ffi.Double()
  external double v_double;

  external NT_String v_string;

  external UnnamedStruct1 v_raw;

  external UnnamedStruct2 arr_boolean;

  external UnnamedStruct3 arr_double;

  external UnnamedStruct4 arr_float;

  external UnnamedStruct5 arr_int;

  external UnnamedStruct6 arr_string;
}

/// Typedefs
typedef NT_Bool = ffi.Int;

class UnnamedStruct1 extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Size()
  external int size;
}

class UnnamedStruct2 extends ffi.Struct {
  external ffi.Pointer<NT_Bool> arr;

  @ffi.Size()
  external int size;
}

class UnnamedStruct3 extends ffi.Struct {
  external ffi.Pointer<ffi.Double> arr;

  @ffi.Size()
  external int size;
}

class UnnamedStruct4 extends ffi.Struct {
  external ffi.Pointer<ffi.Float> arr;

  @ffi.Size()
  external int size;
}

class UnnamedStruct5 extends ffi.Struct {
  external ffi.Pointer<ffi.Int64> arr;

  @ffi.Size()
  external int size;
}

class UnnamedStruct6 extends ffi.Struct {
  external ffi.Pointer<NT_String> arr;

  @ffi.Size()
  external int size;
}

/// NetworkTables Topic Information
class NT_TopicInfo extends ffi.Struct {
  /// Topic handle
  @NT_Topic()
  external int topic;

  /// Topic name
  external NT_String name;

  /// Topic type
  @ffi.Int32()
  external int type;

  /// Topic type string
  external NT_String type_str;

  /// Topic properties JSON string
  external NT_String properties;
}

typedef NT_Topic = NT_Handle;
typedef NT_Handle = ffi.UnsignedInt;

/// NetworkTables Connection Information
class NT_ConnectionInfo extends ffi.Struct {
  /// The remote identifier (as set on the remote node by NT_StartClient4().
  external NT_String remote_id;

  /// The IP address of the remote node.
  external NT_String remote_ip;

  /// The port number of the remote node.
  @ffi.UnsignedInt()
  external int remote_port;

  /// The last time any update was received from the remote node (same scale as
  /// returned by nt::Now()).
  @ffi.Uint64()
  external int last_update;

  /// The protocol version being used for this connection.  This in protocol
  /// layer format, so 0x0200 = 2.0, 0x0300 = 3.0).
  @ffi.UnsignedInt()
  external int protocol_version;
}

/// NetworkTables value event data.
class NT_ValueEventData extends ffi.Struct {
  /// Topic handle.
  @NT_Topic()
  external int topic;

  /// Subscriber/entry handle.
  @NT_Handle()
  external int subentry;

  /// The new value.
  external NT_Value value;
}

/// NetworkTables log message.
class NT_LogMessage extends ffi.Struct {
  /// Log level of the message.  See NT_LogLevel.
  @ffi.UnsignedInt()
  external int level;

  /// The filename of the source file that generated the message.
  external ffi.Pointer<ffi.Char> filename;

  /// The line number in the source file that generated the message.
  @ffi.UnsignedInt()
  external int line;

  /// The message.
  external ffi.Pointer<ffi.Char> message;
}

/// NetworkTables event
class NT_Event extends ffi.Struct {
  /// Listener that triggered this event.
  @NT_Handle()
  external int listener;

  /// Event flags (NT_EventFlags). Also indicates the data included with the
  /// event:
  /// - NT_EVENT_CONNECTED or NT_EVENT_DISCONNECTED: connInfo
  /// - NT_EVENT_PUBLISH, NT_EVENT_UNPUBLISH, or NT_EVENT_PROPERTIES: topicInfo
  /// - NT_EVENT_VALUE_REMOTE, NT_NOTIFY_VALUE_LOCAL: valueData
  /// - NT_EVENT_LOGMESSAGE: logMessage
  @ffi.UnsignedInt()
  external int flags;

  external UnnamedUnion2 data;
}

/// Event data; content depends on flags.
class UnnamedUnion2 extends ffi.Union {
  external NT_ConnectionInfo connInfo;

  external NT_TopicInfo topicInfo;

  external NT_ValueEventData valueData;

  external NT_LogMessage logMessage;
}

/// NetworkTables publish/subscribe option.
class NT_PubSubOption extends ffi.Struct {
  /// Option type.
  @ffi.Int32()
  external int type;

  /// Option value.  1 (true) or 0 (false) for immediate and logging options,
  /// time between updates, in seconds, for periodic option.
  @ffi.Double()
  external double value;
}

typedef NT_Inst = NT_Handle;
typedef NT_Entry = NT_Handle;
typedef NT_Subscriber = NT_Handle;
typedef NT_Publisher = NT_Handle;
typedef NT_MultiSubscriber = NT_Handle;
typedef NT_ListenerPoller = NT_Handle;
typedef NT_Listener = NT_Handle;

/// Event listener callback function.
///
/// @param data            data pointer provided to callback creation function
/// @param event           event info
typedef NT_ListenerCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<NT_Event>)>>;

const int __WORDSIZE = 64;

const int __DARWIN_ONLY_64_BIT_INO_T = 0;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 0;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_64_BIT_INO_T = '\$INODE64';

const String __DARWIN_SUF_1050 = '\$1050';

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int _FORTIFY_SOURCE = 2;

const int NULL = 0;

const int NT_DEFAULT_PORT3 = 1735;

const int NT_DEFAULT_PORT4 = 5810;
